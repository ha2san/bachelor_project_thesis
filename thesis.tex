%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[BScThesis,lablogo]{EPFLreport}
\usepackage{xspace}

\title{Retrofitting defences to C++ code}
\author{Hassan Habib}
\supervisor{Nicolas Badoux}
\adviser{Prof. Dr. sc. ETH Mathias Payer}
%\coadviser{Second Adviser}
%\expert{The External Reviewer}

\newcommand{\sysname}{Retrowrite\xspace}

\begin{document}
\maketitle
%\makededication
%\makeacks

\begin{abstract}
    The \sysname tool enables lateral decomposition of a multi-dimensional
    flux compensator along the timing and space axes.

    The abstract serves as an executive summary of your project.
    Your abstract should cover at least the following topics, 1-2 sentences for
    each: what area you are in, the problem you focus on, why existing work is
    insufficient, what the high-level intuition of your work is, maybe a neat
    design or implementation decision, and key results of your evaluation.

\end{abstract}

%\begin{frenchabstract}
%For a doctoral thesis, you have to provide a French translation of the
%English abstract. For other projects this is optional.
%\end{frenchabstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The introduction is a longer writeup that gently eases the reader into your
thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
In the second paragraph you can introduce the main challenge that you see.
The third paragraph lists why related work is insufficient.
The fourth and fifth paragraphs discuss your approach and why it is needed.
The sixth paragraph will introduce your thesis statement. Think how you can
distill the essence of your thesis into a single sentence.
The seventh paragraph will highlight some of your results
The eights paragraph discusses your core contribution.

This section is usually 3-5 pages.

%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%
In this section, we will give a little bit of backround in order to understand
the experience

\section{Compiler}
Computer programs can be executed in two different ways: they can be interpreted
by a software (an interpreter) or they can be compiled into machine code that can
be then be executed by the hardware.

In the second approach, a compiler is needed to translate the source code into binary code.
Let's have a quick overview of what is contained in a binary executable.

\section{Binary executable}
\subsection{ELF format}
%source man page elf
%
The dominant executable format for binary in Unix system is the ELF\footnote{Executable
and Linkable Format} format. 

An executable file respecting the ELF format must follow a certain layout. At
first it must have an ELF header followed by a program header table or a section
header table, or both. 

There exist multiple tools that can be used to display information about an ELF file. 

Sometimes, we do not have access to the source code but we want to modify the
program for multiple reasons that will be listed later. In this cas we can use
binary rewritting.

\section{Binary rewritting}
%%Pourquoi c'est important ???
Binary rewritting consists of modifying without the source code an executable
in a way that the program still behave as expected. It can be used for multiple
reasons as for example for program optimization, program obfuscation or as in
the case of Retriwrite for security policy enforcement (instrumentation). 

A way to test a software is by using a technique named \textit{fuzzing}. In
order to catch bugs, one might want to compile the program with an address
sanitizer as \textit{ASan}~\cite{ASan} as they are often based on compiler instrumentation.
In the case where the source code is no longer available, the use of a binary
rewritter as for example \textit{Retrowrite}~\cite{dinesh20oakland} might be useful.
%show example of obfuscation

Binary rewritter can be divided into two main approach: Dynamic instrumetation
and static instrumentation

\subsection{Dynamic instrumentation}
%%executer virtuellement le programe
In this scheme, the rewritting is done while the program is executed. Usually
the binary is executed side by side with the rewritter engine. In order
to analyse the binary during the execution, the rewritter might use the OS's
primitves as the PTRACE API in Linux for example.  Only the parts executed can
be analysed and rewritten so they can focused and the most important part.
\subsection{Static instrumentation}
Here, the rewritter operates on binaries stored in persistent memory
(executables that are not being run). In outputs a new binary executable that
corresponds to the initial executable but rewritten. these executables have the
advantage of being almost as fast as the original executable that would have
been compiled for instrumentation.



\subsection{Steps in binary rewritting}
Both dynamic and static instrumentation follow four main steps:
\begin{enumerate}
    \item Parsing:
        This step consist of obtaining the instruction stream from the binary
        and pass it to a disassembler.
        %elaborate
    \item Analysis:
        %elaborate
        This part consists of gaining as much information as possible
    \item Transformation:
        %elaborate
        Here, we must find all the locations where  code must be added. 
    \item Code generation:
        %elaborate
        Here we have to make sure that adding the code does not modify the
        behaviour of the executable (the modified code must run as the
        original). There are multiple techniques for this part.
\end{enumerate}
%add a figure
\begin{figure}[h]
    \includegraphics[width=\linewidth]{required_steps.png}
    \caption{Required steps for binary rewritting}
    \label{fig:steps}
  \end{figure}
\subsection{Code genreation techniques}
There are multiples techniques for the transformation and code generation
parts. The simplest techniques is called \textit{Trampoline}. All new code are
added in new sections in the binary. Branches are then added to redirect to the
right location after an instrumentation point. In this techniques, no reference
or branches are broken.

Another technique is named \textit{Direct}. This is one of the oldest
technique. Here the code is simply overwritten. We have to make sure to reajust
every braches and references.


The technique used by \textit{Retrowrite} is called \textit{Symbolization}. It
consist of transforming the binary into an assembly text file. It transforms
all references constants into assembly labels. Then many tools can instert
instrumentation into the reassembled file. Unlike the trampoline technique,
this method is defined as being \textit{zero-overhead}
%add example of symbolization

\section{Retrowrite}
%link to paper
Retrowrite~\cite{dinesh20oakland} is a binary rewritter developped by HexHive. It uses the
symbolization technique by generating re-assembleable assembly. Their approach
is sound by construction because they use relocations, PC-relative addressing,
and recovered control flow to determine reference constants and symbolize them.
It uses \textit{Capstone} as a disassembler and \textit{pyelftools} as a binary parser.


%%%%%%%%%%%%%%%%
\chapter{Goal}
%%%%%%%%%%%%%%%%
As stated in their paper~\cite{dinesh20oakland}, \textit{Retrowrite} was
firstly designed to support Linux x86-64 PIC binaries that were written in the
\textit{C Programming Language}.
The main obstacle for adding support for \textit{C++} is that the symbolization
for C++ exception handlers is missing. But multiple works were done in order to
add support for C++ as it can be seen in the \textit{Retrowrite} repository
~\cite{gitCommit}


\section{Task}
The task was to test a large number of packages from the \textit{Debian}~\cite{debian} distribution.
Debian being a widely used distribution within the Linux community, we thought
it would be a good idea to use it as a source. We first tested the most used
programs and then we have another list containing a list of programs without a
particular orders. From the results obtained, we try to see if Retrowrite can
indeed rewrite programs written in C++ and we also try to see where it has
trouble. Then we chose some programs where we try to rewrite the binaries with retrowrite
and we try to see where exactly the program crashes.


%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%
All the scripts used can be found in the github 
\href{https://github.com/ha2san/debian_docker/tree/main/scripts}{repository}~\cite{repo}.

The main script is \textit{clone.sh}.It will start several containers which will
each take care of one package. This script also takes care of running the
command that will prepare the results.

\section{Docker}
The first decision was to test \textit{Retrowrite} in
\textit{docker}~\cite{merkel2014docker} containers. This allows us to emulate debian on
any machine. Each container will execute \textit{entrypoint.sh} on a specific package. The
binaries available from the command \textit{apt install}~\cite{apt} are stripped, so
we had to download the source code and compile the program ourselves. Then the
main task was to run the program with the argument "\textit{--help}" and
compare the exit code with the recompiled program from the assembly file
re-assambled by retrowrite. The programs are then sorted according to their
output code.

\section{Linking}
One problem encountered was recompiling the
assembly files by linking them to the correct shared-libraries. To do so, a 
script was written called flib.sh which takes as argument the original binary
file. It will then return, using the command "ldd"\cite{ldd} the list of
libraries to link. 

\section{List of packages}

Having obtained a list of packages from the Debian distribution
\cite{sourcePackage}, we needed a way of filtering to only obtain
a list of packages written in \textit{C++}. To do this, we use the script
\textit{filter\_c++\_packages.sh}. It will simply look in the information given
in \textit{apt show}~\cite{apt} if the package was written in \textit{C++} or
not. 

\section{Filtering the result}
When the docker containers have finished executing their commands, the
\textit{result\_count.sh} script will be executed. This script takes care of searching
and sorting the results by arranging them and putting them in a new folder.
%explain the categories when it is more clear

\section{Three programs}
We have chosen three programs that we will test manually and try to find out
where the errors may come from. The three programs are
flameshot~\cite{flameshot}, bitcoind~\cite{bitcoind} and
fish-shell~\cite{fish}.


%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%

%show table or graph about popular packages
%show table or graph about all tested packages
%show errors with three tested program
%interpret result


%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%%
%
%I can cite other rewritter.



%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
